# A0124503W
###### src\test\ParserTest.java
``` java
import static org.junit.Assert.*;

import java.util.Date;

import org.junit.Test;

import TGParser.DateTimeHandler;
import TGParser.Parser;
import TGUtils.Command;
import TGUtils.Constants;

public class ParserTest {

	@Test
	public void addFloatingTaskNormalTest() throws Exception {

		Command c = Parser.parseCommand("add read a educational book");

		assertEquals(c.getType(), Constants.COMMAND_TYPE.ADD_TASK);
		assertEquals(c.getEventName(), "read a educational book");
	}
	
	@Test
	public void addFloatingTaskPriorityTest() throws Exception {

		Command c = Parser.parseCommand("add read a educational book mid");

		assertEquals(c.getType(), Constants.COMMAND_TYPE.ADD_TASK);
		assertEquals(c.getEventName(), "read a educational book");
		assertEquals(c.getEventPriority(), 2);
	}

	@Test
	public void addDeadlineNormalTest() throws Exception {

		Command c = Parser.parseCommand("add cook curry ayam by 21/10/2015 09:00");

		assertEquals(c.getType(), Constants.COMMAND_TYPE.ADD_DEADLINE);
		System.out.println(c.getEventName());
		assertEquals(c.getEventName(), "cook curry ayam");
	}

	@Test
	public void addDeadlinePriorityTest() throws Exception {

		Command c = Parser.parseCommand("add cook curry ayam by 21/10/2015 09:00 high");

		assertEquals(c.getType(), Constants.COMMAND_TYPE.ADD_DEADLINE);
		System.out.println(c.getEventName());
		assertEquals(c.getEventName(), "cook curry ayam");
		assertEquals(c.getEventPriority(), 3);
	}
	
	@Test
	public void addDeadlineNormalWithFlexibleDateTest() throws Exception {
		String testString;
		Date testDate;

		Command c = Parser.parseCommand("add cook curry ayam by 21/10/2015");

		assertEquals(c.getType(), Constants.COMMAND_TYPE.ADD_DEADLINE);
		System.out.println(c.getEventName());
		assertEquals(c.getEventName(), "cook curry ayam");
		assertEquals(c.getEventEnd().toString(), "Wed Oct 21 23:59:00 SGT 2015");
		
		Command c1 = Parser.parseCommand("add cook curry ayam by 21/10");

		assertEquals(c1.getType(), Constants.COMMAND_TYPE.ADD_DEADLINE);
		System.out.println(c1.getEventName());
		assertEquals(c1.getEventName(), "cook curry ayam");
		
		testString = DateTimeHandler.defaultDateTimeCheck("21/10", Constants.DEADLINE);
		testDate = DateTimeHandler.dateConverter(testString);
		assertEquals(c1.getEventEnd(), testDate);
		
		Command c2 = Parser.parseCommand("add cook curry ayam by 15:09");

		assertEquals(c2.getType(), Constants.COMMAND_TYPE.ADD_DEADLINE);
		System.out.println(c2.getEventName());
		assertEquals(c2.getEventName(), "cook curry ayam");
		
		testString = DateTimeHandler.defaultDateTimeCheck("15:09", Constants.DEADLINE);
		testDate = DateTimeHandler.dateConverter(testString);
		assertEquals(c2.getEventEnd(), testDate);
		
		Command c3 = Parser.parseCommand("add cook curry ayam by 21/10 15:05");

		assertEquals(c3.getType(), Constants.COMMAND_TYPE.ADD_DEADLINE);
		System.out.println(c3.getEventName());
		assertEquals(c3.getEventName(), "cook curry ayam");
		
		testString = DateTimeHandler.defaultDateTimeCheck("21/10 15:05", Constants.DEADLINE);
		testDate = DateTimeHandler.dateConverter(testString);
		assertEquals(c3.getEventEnd(), testDate);
	}
	
	@Test
	public void addDeadlinePriorityWithFlexibleDateTimeTest() throws Exception {
		String testString;
		Date testDate;

		Command c = Parser.parseCommand("add cook curry ayam by 21/10/2015 mid");

		assertEquals(c.getType(), Constants.COMMAND_TYPE.ADD_DEADLINE);
		System.out.println(c.getEventName());
		assertEquals(c.getEventName(), "cook curry ayam");
		assertEquals(c.getEventEnd().toString(), "Wed Oct 21 23:59:00 SGT 2015");
		assertEquals(c.getEventPriority(), 2);
		
		Command c1 = Parser.parseCommand("add cook curry ayam by 21/10 high");

		assertEquals(c1.getType(), Constants.COMMAND_TYPE.ADD_DEADLINE);
		System.out.println(c1.getEventName());
		assertEquals(c1.getEventName(), "cook curry ayam");
		
		testString = DateTimeHandler.defaultDateTimeCheck("21/10", Constants.DEADLINE);
		testDate = DateTimeHandler.dateConverter(testString);
		assertEquals(c1.getEventEnd(), testDate);
		assertEquals(c1.getEventPriority(), 3);
		
		Command c2 = Parser.parseCommand("add cook curry ayam by 15:09 mid");

		assertEquals(c2.getType(), Constants.COMMAND_TYPE.ADD_DEADLINE);
		System.out.println(c2.getEventName());
		assertEquals(c2.getEventName(), "cook curry ayam");
		
		testString = DateTimeHandler.defaultDateTimeCheck("15:09", Constants.DEADLINE);
		testDate = DateTimeHandler.dateConverter(testString);
		assertEquals(c2.getEventEnd(), testDate);
		assertEquals(c2.getEventPriority(), 2);
		
		Command c3 = Parser.parseCommand("add cook curry ayam by 21/10 15:05 low");

		assertEquals(c3.getType(), Constants.COMMAND_TYPE.ADD_DEADLINE);
		System.out.println(c3.getEventName());
		assertEquals(c3.getEventName(), "cook curry ayam");
		
		testString = DateTimeHandler.defaultDateTimeCheck("21/10 15:05", Constants.DEADLINE);
		testDate = DateTimeHandler.dateConverter(testString);
		assertEquals(c3.getEventEnd(), testDate);
		assertEquals(c3.getEventPriority(), 1);
	}

	@Test
	public void addScheduleNormalTest() throws Exception {

		Command c = Parser.parseCommand("add bring Tang Hao to school from 21/10/2015 09:00 to 22/02/2016 09:00");

		assertEquals(c.getType(), Constants.COMMAND_TYPE.ADD_SCHEDULE);
		assertEquals(c.getEventName(), "bring Tang Hao to school");
	}
	
	@Test
	public void addSchedulePriorityTest() throws Exception {

		Command c = Parser.parseCommand("add bring Tang Hao to school from 21/10/2015 09:00 to 22/02/2016 09:00 low");

		assertEquals(c.getType(), Constants.COMMAND_TYPE.ADD_SCHEDULE);
		assertEquals(c.getEventName(), "bring Tang Hao to school");
		assertEquals(c.getEventPriority(), 1);
	}
	
	@Test
	public void addScheduleNormalWithFlexibleDateTimeTest() throws Exception {
		String testStringStart, testStringEnd;
		Date testDateStart, testDateEnd;

		Command c = Parser.parseCommand("add cook curry ayam from 21/10/2015 to 24/10/2015");

		assertEquals(c.getType(), Constants.COMMAND_TYPE.ADD_SCHEDULE);
		System.out.println(c.getEventName());
		assertEquals(c.getEventName(), "cook curry ayam");
		
		testStringStart = DateTimeHandler.defaultDateTimeCheck("21/10/2015", Constants.SCHEDULE);
		testDateStart = DateTimeHandler.dateConverter(testStringStart);
		testStringEnd = DateTimeHandler.defaultDateTimeCheck("24/10/2015", Constants.SCHEDULE);
		testDateEnd = DateTimeHandler.dateConverter(testStringEnd);
		
		assertEquals(c.getEventEnd(), testDateEnd);
		assertEquals(c.getEventStart(), testDateStart);
		
		Command c1 = Parser.parseCommand("add cooking for parents from 16:00 to 19:00");

		assertEquals(c1.getType(), Constants.COMMAND_TYPE.ADD_SCHEDULE);
		System.out.println(c1.getEventName());
		assertEquals(c1.getEventName(), "cooking for parents");
		
		testStringStart = DateTimeHandler.defaultDateTimeCheck("16:00", Constants.SCHEDULE);
		testDateStart = DateTimeHandler.dateConverter(testStringStart);
		testStringEnd = DateTimeHandler.defaultDateTimeCheck("19:00", Constants.SCHEDULE);
		testDateEnd = DateTimeHandler.dateConverter(testStringEnd);
		
		assertEquals(c1.getEventEnd(), testDateEnd);
		assertEquals(c1.getEventStart(), testDateStart);
		
		Command c2 = Parser.parseCommand("add GEK1901 Presentation from 21/10 to 24/10");

		assertEquals(c2.getType(), Constants.COMMAND_TYPE.ADD_SCHEDULE);
		System.out.println(c2.getEventName());
		assertEquals(c2.getEventName(), "GEK1901 Presentation");
		
		testStringStart = DateTimeHandler.defaultDateTimeCheck("21/10", Constants.SCHEDULE);
		testDateStart = DateTimeHandler.dateConverter(testStringStart);
		testStringEnd = DateTimeHandler.defaultDateTimeCheck("24/10", Constants.SCHEDULE);
		testDateEnd = DateTimeHandler.dateConverter(testStringEnd);
		
		assertEquals(c2.getEventEnd(), testDateEnd);
		assertEquals(c2.getEventStart(), testDateStart);
		
		Command c3 = Parser.parseCommand("add guitar rehearsal from 21/10 15:05 to 21/10 16:05");

		assertEquals(c3.getType(), Constants.COMMAND_TYPE.ADD_SCHEDULE);
		System.out.println(c3.getEventName());
		assertEquals(c3.getEventName(), "guitar rehearsal");
		
		testStringStart = DateTimeHandler.defaultDateTimeCheck("21/10 15:05", Constants.SCHEDULE);
		testDateStart = DateTimeHandler.dateConverter(testStringStart);
		testStringEnd = DateTimeHandler.defaultDateTimeCheck("21/10 16:05", Constants.SCHEDULE);
		testDateEnd = DateTimeHandler.dateConverter(testStringEnd);
		
		assertEquals(c3.getEventEnd(), testDateEnd);
		assertEquals(c3.getEventStart(), testDateStart);
		
	}
	
	@Test
	public void addSchedulePriorityWithFlexibleDateTimeTest() throws Exception {
		String testStringStart, testStringEnd;
		Date testDateStart, testDateEnd;

		Command c = Parser.parseCommand("add cook curry ayam from 21/10/2015 to 24/10/2015 high");

		assertEquals(c.getType(), Constants.COMMAND_TYPE.ADD_SCHEDULE);
		System.out.println(c.getEventName());
		assertEquals(c.getEventName(), "cook curry ayam");
		assertEquals(c.getEventPriority(), 3);
		
		testStringStart = DateTimeHandler.defaultDateTimeCheck("21/10/2015", Constants.SCHEDULE);
		testDateStart = DateTimeHandler.dateConverter(testStringStart);
		testStringEnd = DateTimeHandler.defaultDateTimeCheck("24/10/2015", Constants.SCHEDULE);
		testDateEnd = DateTimeHandler.dateConverter(testStringEnd);
		
		assertEquals(c.getEventEnd(), testDateEnd);
		assertEquals(c.getEventStart(), testDateStart);
		
		Command c1 = Parser.parseCommand("add cooking for parents from 16:00 to 19:00 mid");

		assertEquals(c1.getType(), Constants.COMMAND_TYPE.ADD_SCHEDULE);
		System.out.println(c1.getEventName());
		assertEquals(c1.getEventName(), "cooking for parents");
		assertEquals(c1.getEventPriority(), 2);
		
		testStringStart = DateTimeHandler.defaultDateTimeCheck("16:00", Constants.SCHEDULE);
		testDateStart = DateTimeHandler.dateConverter(testStringStart);
		testStringEnd = DateTimeHandler.defaultDateTimeCheck("19:00", Constants.SCHEDULE);
		testDateEnd = DateTimeHandler.dateConverter(testStringEnd);
		
		assertEquals(c1.getEventEnd(), testDateEnd);
		assertEquals(c1.getEventStart(), testDateStart);
		
		Command c2 = Parser.parseCommand("add GEK1901 Presentation from 21/10 to 24/10 low");

		assertEquals(c2.getType(), Constants.COMMAND_TYPE.ADD_SCHEDULE);
		System.out.println(c2.getEventName());
		assertEquals(c2.getEventName(), "GEK1901 Presentation");
		assertEquals(c2.getEventPriority(), 1);
		
		testStringStart = DateTimeHandler.defaultDateTimeCheck("21/10", Constants.SCHEDULE);
		testDateStart = DateTimeHandler.dateConverter(testStringStart);
		testStringEnd = DateTimeHandler.defaultDateTimeCheck("24/10", Constants.SCHEDULE);
		testDateEnd = DateTimeHandler.dateConverter(testStringEnd);
		
		assertEquals(c2.getEventEnd(), testDateEnd);
		assertEquals(c2.getEventStart(), testDateStart);
		
		Command c3 = Parser.parseCommand("add guitar rehearsal from 21/10 15:05 to 21/10 16:05 high");

		assertEquals(c3.getType(), Constants.COMMAND_TYPE.ADD_SCHEDULE);
		System.out.println(c3.getEventName());
		assertEquals(c3.getEventName(), "guitar rehearsal");
		assertEquals(c.getEventPriority(), 3);
		
		testStringStart = DateTimeHandler.defaultDateTimeCheck("21/10 15:05", Constants.SCHEDULE);
		testDateStart = DateTimeHandler.dateConverter(testStringStart);
		testStringEnd = DateTimeHandler.defaultDateTimeCheck("21/10 16:05", Constants.SCHEDULE);
		testDateEnd = DateTimeHandler.dateConverter(testStringEnd);
		
		assertEquals(c3.getEventEnd(), testDateEnd);
		assertEquals(c3.getEventStart(), testDateStart);
		
	}

	@Test 
	public void deleteTest() throws Exception {
		
		Command c = Parser.parseCommand("delete t1");
		
		assertEquals(c.getType(), Constants.COMMAND_TYPE.DELETE);
		assertEquals(c.getDisplayedIndex(), "t1");
	}
	
}
```
###### src\TGExceptions\TaskDateExistenceException.java
``` java
@SuppressWarnings("serial")
public class TaskDateExistenceException extends Exception {
	public TaskDateExistenceException() { super();}
}
```
###### src\TGParser\DateTimeHandler.java
``` java
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

import TGExceptions.AbnormalScheduleTimeException;
import TGExceptions.TaskDateExistenceException;
import TGUtils.Constants;

public class DateTimeHandler {

	public static Date dateConverter(String dateString) throws ParseException{
		DateFormat format = new SimpleDateFormat(Constants.DEFAULT_DATE_FORMAT);
		format.setLenient(false); 
		
		Date date = format.parse(dateString);
		return date;
	}
	
	public static String defaultDateTimeCheck(String date, String eventType) {
		String modifiedString = date;
		String todayDate = getTodayDate();
		String thisYear = getThisYear();

		String[] dayMonthYearSplit = date.split(Constants.DAY_MONTH_YEAR_SPLIT);
		String[] hourMinuteSplit = date.split(Constants.HOUR_MINUTE_SPLIT);

		if(dayMonthYearSplit.length == 1) { //case 1: when a user does not enter a date, but with time.
			modifiedString = modifiedString.substring(0, modifiedString.length() - 5) + todayDate + modifiedString.substring(modifiedString.length() - 5);	
		} else if (hourMinuteSplit.length == 2 && dayMonthYearSplit.length == 2) {//case 2, when the user provides a time and date without year
			modifiedString = modifiedString.substring(0, modifiedString.length() - 6) + thisYear + modifiedString.substring(modifiedString.length() - 5);	
		} else if (hourMinuteSplit.length == 1 && dayMonthYearSplit.length != 2) {//case 3: when a user does not enter a time, but with a full date with year.
			if(eventType.equals(Constants.DEADLINE))
				modifiedString = modifiedString + Constants.SPACE + Constants.DEFAULT_DEADLINE_TIME;
			else if(eventType.equals(Constants.SCHEDULE))
				modifiedString = modifiedString + Constants.SPACE + Constants.DEFAULT_SCHEDULE_TIME;	
		} else if (hourMinuteSplit.length == 1 && dayMonthYearSplit.length == 2) {//case 4: when a user does not enter a time, but with a date without year.
			if(eventType.equals(Constants.DEADLINE))
				modifiedString = modifiedString + thisYear + Constants.DEFAULT_DEADLINE_TIME;
			else if(eventType.equals(Constants.SCHEDULE))
				modifiedString = modifiedString + thisYear + Constants.DEFAULT_SCHEDULE_TIME;
		}
		return modifiedString;
	}
	
	/**
	 * Checks whether if the time and date are integers.
	 * This method is the first check as to whether they are in the default format
	 * @param num
	 * @return
	 * @throws NumberFormatException
	 * @throws ArrayIndexOutOfBoundsException
	 */
	@SuppressWarnings("unused")
	public static boolean isNumber(String timeAndDate) throws NumberFormatException, ArrayIndexOutOfBoundsException {
		int hourInteger, minuteInteger, dayInteger, monthInteger, yearInteger;
		String hour, minute, day, month, year;
		
		String[] dayMonthYearSplit, hourMinuteSplit;
		String[] timeAndDateSplit = timeAndDate.split(Constants.SPACE);

		if (timeAndDateSplit.length == 1) {
		    dayMonthYearSplit = timeAndDateSplit[0].split(Constants.DAY_MONTH_YEAR_SPLIT);
			hourMinuteSplit = timeAndDateSplit[0].split(Constants.HOUR_MINUTE_SPLIT);

			if(dayMonthYearSplit.length == 1) {
				hour = hourMinuteSplit[0];
				hourInteger = Integer.parseInt(hour);

				minute = hourMinuteSplit[1];
				minuteInteger = Integer.parseInt(minute);
			} else if (hourMinuteSplit.length == 1) {
				if(dayMonthYearSplit.length == 2) {
					day = dayMonthYearSplit[0];
					dayInteger = Integer.parseInt(day);

					month = dayMonthYearSplit[1];
					monthInteger = Integer.parseInt(month);
				} else {
					day = dayMonthYearSplit[0];
					dayInteger = Integer.parseInt(day);

					month = dayMonthYearSplit[1];
					monthInteger = Integer.parseInt(month);

					year = dayMonthYearSplit[2];
					yearInteger = Integer.parseInt(year);
				
				}
			}
		} else {
			dayMonthYearSplit = timeAndDateSplit[0].split(Constants.DAY_MONTH_YEAR_SPLIT);
			hourMinuteSplit = timeAndDateSplit[1].split(Constants.HOUR_MINUTE_SPLIT);

			day = dayMonthYearSplit[0];
			dayInteger = Integer.parseInt(day);

			month = dayMonthYearSplit[1];
			monthInteger = Integer.parseInt(month);

			hour = hourMinuteSplit[0];
			hourInteger = Integer.parseInt(hour);

			minute = hourMinuteSplit[1];
			minuteInteger = Integer.parseInt(minute);
		}
		return true;
	}
	
	public static void checkTaskValidity(String input) throws TaskDateExistenceException {
		int inputLength = input.length();
		int inputLengthCheck = input.replaceAll(Constants.DATE_DETECTION, Constants.NULL).length();

		if(inputLength - inputLengthCheck != 0)
			throw new TaskDateExistenceException();

		inputLengthCheck = input.replaceAll(Constants.TIME_DETECTION, Constants.NULL).length();

		if(inputLength - inputLengthCheck != 0)
			throw new TaskDateExistenceException();

	}
	
	public static void startAndEndTimeValidation(String start, String end) throws AbnormalScheduleTimeException, ParseException{
	
		String finalEndDate = DateTimeHandler.defaultDateTimeCheck(end, Constants.SCHEDULE);
		String finalStartDate = DateTimeHandler.defaultDateTimeCheck(start, Constants.SCHEDULE);
		
		Date endDate = DateTimeHandler.dateConverter(finalEndDate);
		Date startDate = DateTimeHandler.dateConverter(finalStartDate); 
		
		if(startDate.compareTo(endDate) >= 0) {
			throw new AbnormalScheduleTimeException();
		}
	}

	private static String getTodayDate() {
		DateFormat df = new SimpleDateFormat(Constants.DEFAULT_DATE_FORMAT);
		Calendar cal = Calendar.getInstance();

		String today = df.format(cal.getTime());
		return today.substring(0, today.length() - 6) + Constants.SPACE; 
	}
	
	private static String getThisYear() {
		DateFormat df = new SimpleDateFormat(Constants.DEFAULT_DATE_FORMAT);
		Calendar cal = Calendar.getInstance();

		String today = df.format(cal.getTime());
		return Constants.DAY_MONTH_YEAR_SPLIT + today.substring(6, today.length() - 6) + Constants.SPACE; 		
	}
	
}
```
###### src\TGParser\EventCheck.java
``` java
import TGExceptions.TaskDateExistenceException;
import TGUtils.Constants;

public class EventCheck {

	// Attributes
	private static String[] deadlineCheckArray;
	private static String[] scheduleStartAndEnd;
	private static String[] scheduleCheckArray;

	private static String deadlineDateAndTime;
	private static String scheduleStartDateAndTime;
	private static String scheduleEndDateAndTime;

	public EventCheck(String input) {
		deadlineCheckArray = input.split(Constants.DEADLINE_SPLIT);
		deadlineDateAndTime = deadlineCheckArray[deadlineCheckArray.length - 1];

		scheduleStartAndEnd = input.split(Constants.SCHEDULE_FIRST_SPLIT);
		scheduleCheckArray = scheduleStartAndEnd[scheduleStartAndEnd.length - 1].split(Constants.SCHEDULE_SECOND_SPLIT);
		scheduleStartDateAndTime = scheduleCheckArray[0];
		
		if(scheduleCheckArray.length > 1)
			scheduleEndDateAndTime = scheduleCheckArray[1];
	}
	
	public String getDeadlineDateAndTime() {
		return deadlineDateAndTime;
	}

	public String getScheduleStartDateAndTime() {
		return scheduleStartDateAndTime;
	}

	public String getScheduleEndDateAndTime() {
		return scheduleEndDateAndTime;
	}
	
	public EventCheck reInitialize(String input) {
		EventCheck newEventCheck = new EventCheck(input);
		return newEventCheck;
	}

	public boolean possibleDate(String input) throws NumberFormatException, ArrayIndexOutOfBoundsException {
		boolean isPossibleDate = false;

		if (input.equals(Constants.DEADLINE)) {
			isPossibleDate = DateTimeHandler.isNumber(getDeadlineDateAndTime());
		} else if (input.equals(Constants.SCHEDULE_START)) {
			isPossibleDate = DateTimeHandler.isNumber(getScheduleStartDateAndTime());
		} else if (input.equals(Constants.SCHEDULE_END)) {
			isPossibleDate = DateTimeHandler.isNumber(getScheduleEndDateAndTime());
		}

		return isPossibleDate;
	}

	public String getEventName(String input) {
		String eventName = Constants.NULL;

		if (input.equals(Constants.DEADLINE)) {
			eventName = getName(Constants.DEADLINE_SPLIT, deadlineCheckArray);
		} else if (input.equals(Constants.SCHEDULE)) {
			eventName = getName(Constants.SCHEDULE_FIRST_SPLIT, scheduleStartAndEnd);
		}

		return eventName;
	}
	
	public void isProperFloatingTaskCheck() throws TaskDateExistenceException {	
		if(deadlineCheckArray.length > 1) {
			DateTimeHandler.checkTaskValidity(getDeadlineDateAndTime());
		}

		if(scheduleStartAndEnd.length > 1 && scheduleCheckArray.length > 1) {
			DateTimeHandler.checkTaskValidity(getScheduleEndDateAndTime());
			DateTimeHandler.checkTaskValidity(getScheduleStartDateAndTime());
		}
	}

	private String getName(String splitSeq, String[] array) {
		StringBuilder name = new StringBuilder();
		for (int i = 0; i < array.length - 1; i++) {
			name.append(array[i]);
			if (i != array.length - 2) {
				name.append(splitSeq);
			}
		}
		return name.toString();
	}

}
```
###### src\TGParser\Parser.java
``` java
import java.text.ParseException;
import java.util.Date;

import TGExceptions.AbnormalScheduleTimeException;
import TGExceptions.TaskDateExistenceException;
import TGUtils.Command;
import TGUtils.Constants;

public class Parser {

	public static Command parseCommand(String input) throws ParseException, IndexOutOfBoundsException, AbnormalScheduleTimeException, TaskDateExistenceException {
		String command = getFirstWord(input);
		String event = removeFirstWord(input);
		String displayedIndex;
		String deadlineDateAndTime, scheduleStartDateAndTime, scheduleEndDateAndTime;
		String finalStartDate, finalEndDate;

		Constants.COMMAND_TYPE commandType = findCommandType(command);

		Date endDate, startDate;

		Command tempCommand = new Command();
		tempCommand.setType(commandType);
		tempCommand.setIsUserCommand(true);

		PriorityCheck priorityCheck = new PriorityCheck(event);
		EventCheck eventCheck = new EventCheck(event);

		switch (commandType) {
		case ADD:

			boolean withPriority = priorityCheck.containsPriority();
			if (withPriority == true) {
				int eventPriority = priorityCheck.getPriorityNumber();
				tempCommand.setEventPriority(eventPriority);

				event = priorityCheck.removePriorityFromEventName();
			}

			eventCheck = eventCheck.reInitialize(event);
			try { // deadline
				if (eventCheck.possibleDate(Constants.DEADLINE) == true) {
					
					deadlineDateAndTime = eventCheck.getDeadlineDateAndTime();

					finalEndDate = DateTimeHandler.defaultDateTimeCheck(deadlineDateAndTime, Constants.DEADLINE);

					endDate = DateTimeHandler.dateConverter(finalEndDate);

					tempCommand.setEventEnd(endDate);
					tempCommand.setEventName(eventCheck.getEventName(Constants.DEADLINE));
					tempCommand.setType(Constants.COMMAND_TYPE.ADD_DEADLINE);
					break;
				}
			} catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {
				
				try { // schedule
					if (eventCheck.possibleDate(Constants.SCHEDULE_START) && eventCheck.possibleDate(Constants.SCHEDULE_END)) {

						scheduleStartDateAndTime = eventCheck.getScheduleStartDateAndTime();
						scheduleEndDateAndTime = eventCheck.getScheduleEndDateAndTime();

						DateTimeHandler.startAndEndTimeValidation(scheduleStartDateAndTime, scheduleEndDateAndTime);

						finalEndDate = DateTimeHandler.defaultDateTimeCheck(scheduleEndDateAndTime, Constants.SCHEDULE);
						finalStartDate = DateTimeHandler.defaultDateTimeCheck(scheduleStartDateAndTime, Constants.SCHEDULE);

						endDate = DateTimeHandler.dateConverter(finalEndDate);
						startDate = DateTimeHandler.dateConverter(finalStartDate);

						tempCommand.setEventStart(startDate);
						tempCommand.setEventEnd(endDate);
						tempCommand.setEventName(eventCheck.getEventName(Constants.SCHEDULE));
						tempCommand.setType(Constants.COMMAND_TYPE.ADD_SCHEDULE);
						break;
					}
				} catch (NumberFormatException | ArrayIndexOutOfBoundsException f) {
					
					//task
					eventCheck.isProperFloatingTaskCheck();

					tempCommand.setEventName(event);
					tempCommand.setType(Constants.COMMAND_TYPE.ADD_TASK); 
				}
			}
			break;
		case DISPLAY:
			break;
		case UPDATE_NAME:
			displayedIndex = getFirstWord(event);
			String updatedName = removeFirstWord(event);
			
			tempCommand.setDisplayedIndex(displayedIndex);
			tempCommand.setEventName(updatedName);
			break;
		case UPDATE_START:
			displayedIndex = getFirstWord(event);
			String newStart = removeFirstWord(event);
			newStart = updateDateTimeCheck(displayedIndex, newStart);	
			Date updatedStart = DateTimeHandler.dateConverter(newStart);
			
			tempCommand.setDisplayedIndex(displayedIndex);
			tempCommand.setEventStart(updatedStart);
			break;
		case UPDATE_END:
			displayedIndex = getFirstWord(event);
			String newEnd = removeFirstWord(event);	
			newEnd = updateDateTimeCheck(displayedIndex, newEnd);
			Date updatedEnd = DateTimeHandler.dateConverter(newEnd);
			
			tempCommand.setDisplayedIndex(displayedIndex);
			tempCommand.setEventEnd(updatedEnd);
			break;
		case UPDATE_PRIORITY:
			displayedIndex = getFirstWord(event);
			int updatedPriority = priorityCheck.getPriorityNumber();
			
			tempCommand.setDisplayedIndex(displayedIndex);
			tempCommand.setEventPriority(updatedPriority);
			break;
		case UPDATE_CATEGORY:
			displayedIndex = getFirstWord(event);
			String updatedCategory = removeFirstWord(event);
			
			tempCommand.setDisplayedIndex(displayedIndex);
			tempCommand.setEventCategory(updatedCategory);
			break;
		case DELETE:
			displayedIndex = getFirstWord(event);
			tempCommand.setDisplayedIndex(displayedIndex);
			break;
		case UNDO:
			break;
		case DONE:
			displayedIndex = getFirstWord(event);
			tempCommand.setDisplayedIndex(displayedIndex);
			break;
		case SORT_NAME:
			break;
		case SORT_START:
			break;
		case SORT_END:
			break;
		case SORT_PRIORITY:
			break;
		case SEARCH:
			tempCommand.setSearchKey(event.toLowerCase());
			break;
		case TOGGLE:
			break;
		case PATH:
			tempCommand.setPath(event);
			break;
		case IMPORT:
			tempCommand.setPath(event);
			break;
		case EXIT:
			break;
		case INVALID:
			break;
		default:
			tempCommand.setType(Constants.COMMAND_TYPE.EXCEPTION);
		}		
		return tempCommand;
	}

	private static String updateDateTimeCheck(String displayedIndex, String date) {
		if (displayedIndex.charAt(0) == Constants.DEADLINE_CHAR) {
			date = DateTimeHandler.defaultDateTimeCheck(date, Constants.DEADLINE);
		} else if (displayedIndex.charAt(0) == Constants.SCHEDULE_CHAR) {
			date = DateTimeHandler.defaultDateTimeCheck(date, Constants.SCHEDULE);
		}		
		return date;
	}

	private static Constants.COMMAND_TYPE findCommandType(String commandTypeString) {
		if (commandTypeString.equalsIgnoreCase(Constants.ADD)) {
			return Constants.COMMAND_TYPE.ADD;
		} else if (commandTypeString.equalsIgnoreCase(Constants.DISPLAY)) {
			return Constants.COMMAND_TYPE.DISPLAY;
		} else if (commandTypeString.equalsIgnoreCase(Constants.DELETE)) {
			return Constants.COMMAND_TYPE.DELETE;
		} else if (commandTypeString.equalsIgnoreCase(Constants.EXIT)) {
			return Constants.COMMAND_TYPE.EXIT;
		} else if (commandTypeString.equalsIgnoreCase(Constants.UNDO)) {
			return Constants.COMMAND_TYPE.UNDO;
		} else if (commandTypeString.equalsIgnoreCase(Constants.UPDATE_NAME)) {
			return Constants.COMMAND_TYPE.UPDATE_NAME;
		} else if (commandTypeString.equalsIgnoreCase(Constants.UPDATE_END)) {
			return Constants.COMMAND_TYPE.UPDATE_END;
		} else if (commandTypeString.equalsIgnoreCase(Constants.UPDATE_START)) {
			return Constants.COMMAND_TYPE.UPDATE_START;
		} else if (commandTypeString.equalsIgnoreCase(Constants.UPDATE_PRIORITY)) {
			return Constants.COMMAND_TYPE.UPDATE_PRIORITY;
		} else if (commandTypeString.equalsIgnoreCase(Constants.UPDATE_CATEGORY)) {
			return Constants.COMMAND_TYPE.UPDATE_CATEGORY;
		} else if (commandTypeString.equalsIgnoreCase(Constants.DONE)) {
			return Constants.COMMAND_TYPE.DONE;
		} else if (commandTypeString.equalsIgnoreCase(Constants.SORT_NAME)) {
			return Constants.COMMAND_TYPE.SORT_NAME;
		} else if (commandTypeString.equalsIgnoreCase(Constants.SORT_START)) {
			return Constants.COMMAND_TYPE.SORT_START;
		} else if (commandTypeString.equalsIgnoreCase(Constants.SORT_END)) {
			return Constants.COMMAND_TYPE.SORT_END;
		} else if (commandTypeString.equalsIgnoreCase(Constants.SORT_PRIORITY)) {
			return Constants.COMMAND_TYPE.SORT_PRIORITY;
		} else if (commandTypeString.equalsIgnoreCase(Constants.SEARCH)) {
			return Constants.COMMAND_TYPE.SEARCH;
		} else if (commandTypeString.equalsIgnoreCase(Constants.PATH)) {
			return Constants.COMMAND_TYPE.PATH;
		} else if (commandTypeString.equalsIgnoreCase(Constants.IMPORT)) {
			return Constants.COMMAND_TYPE.IMPORT;
		} else if (commandTypeString.equalsIgnoreCase(Constants.TOGGLE)) {
			return Constants.COMMAND_TYPE.TOGGLE;
		} else {
			return Constants.COMMAND_TYPE.INVALID;
		}
	}

	private static String removeFirstWord(String input) {
		return input.replaceFirst(getFirstWord(input), Constants.NULL).trim();
	}

	private static String getFirstWord(String input) {
		String inputString = input.trim().split(Constants.WORD_SPLIT)[0];

		if (inputString.equals(Constants.UPDATE) || inputString.equals(Constants.SORT)) {
			inputString += Constants.SPACE + input.trim().split(Constants.WORD_SPLIT)[1];
		}
		return inputString;
	}
}
```
###### src\TGParser\PriorityCheck.java
``` java
import TGUtils.Constants;

public class PriorityCheck {

	// Attributes
	private static String[] inputArray;
	private static String priority;
	
	public PriorityCheck(String input) {
		inputArray = input.split(Constants.SPACE);
		priority = inputArray[inputArray.length - 1];
	}

	// Class methods
	public boolean containsPriority() {
		boolean hasPriority = hasPriority(priority);
		return hasPriority;
	}

	public int getPriorityNumber() {
		int priorityNumber = checkPriority(priority);
		return priorityNumber;
	}
	
	public String removePriorityFromEventName() {
		String modifiedEvent = Constants.NULL;
		String finalResult = Constants.NULL;
		
		for(int i = 0; i < inputArray.length - 1; i++) {
			modifiedEvent = modifiedEvent + inputArray[i] + Constants.SPACE;
		}
		
		finalResult = modifiedEvent.substring(0, modifiedEvent.length() - 1);	
		return finalResult;
	}

	// Private methods
	private int checkPriority(String input) {
		if (input.equalsIgnoreCase(Constants.HIGH)) {
			return 3;
		} else if (input.equalsIgnoreCase(Constants.MID)) {
			return 2;
		} else if (input.equalsIgnoreCase(Constants.LOW)) {
			return 1;
		} else {
			return -1;
		}
	}

	private boolean hasPriority(String input) {
		return (input.equalsIgnoreCase(Constants.HIGH) || input.equalsIgnoreCase(Constants.MID) || input.equalsIgnoreCase(Constants.LOW));		
	}
}
```
###### src\TGUtils\Constants.java
``` java
	/*
	 * Parser Constants
	 */
	public static final String DEADLINE_SPLIT = " by ";
	public static final String SCHEDULE_FIRST_SPLIT = " from ";
	public static final String SCHEDULE_SECOND_SPLIT = " to ";
	
	public static final String DEADLINE = "deadline";
	public static final String SCHEDULE = "schedule";
	public static final String SCHEDULE_END = "scheduleEnd";
	public static final String SCHEDULE_START = "scheduleStart";
	public static final String SORT = "sort";
	public static final String UPDATE = "update";
	public static final String WORD_SPLIT = "\\s+";
	public static final String TOGGLE = "toggle";
	public static final String IMPORT = "import";
	public static final String PATH = "path";
	public static final String SEARCH = "search";
	public static final String SORT_PRIORITY = "sort priority";
	public static final String SORT_END = "sort end";
	public static final String SORT_START = "sort start";
	public static final String SORT_NAME = "sort name";
	public static final String DONE = "done";
	public static final String UPDATE_CATEGORY = "update category";
	public static final String UPDATE_PRIORITY = "update priority";
	public static final String UPDATE_START = "update start";
	public static final String UPDATE_END = "update end";
	public static final String UPDATE_NAME = "update name";
	public static final String UNDO = "undo";
	public static final String EXIT = "exit";
	public static final String DELETE = "delete";
	public static final String DISPLAY = "display";
	public static final String ADD = "add";
	
	public static final String DEFAULT_SCHEDULE_TIME = "00:00";
	public static final String DEFAULT_DEADLINE_TIME = "23:59";
	public static final String HOUR_MINUTE_SPLIT = ":";
	public static final String DAY_MONTH_YEAR_SPLIT = "/";
	public static final String NULL = "";
	public static final String TIME_DETECTION = "[0-9]:[0-9]";
	public static final String DATE_DETECTION = "[0-9]/[0-9]";
	public static final String SPACE = " ";
	public static final char DEADLINE_CHAR = 'd';
	public static final char SCHEDULE_CHAR = 's';

	public static final String LOW = "LOW";
	public static final String MID = "MID";
	public static final String HIGH = "HIGH";

	/*
	 * Tanguo Constants
	 */
	public static final String DEFAULT_DATE_FORMAT = "dd/MM/yyyy HH:mm";
	public static final int DATE_LENGTH = 17;
	public static final String NEW_LINE = "\n";

	public static final String TANGGUO_START = "Welcome to TangGuo. %s is ready for use";
	public static final String TANGGUO_ADD_SUCCESS = "Added to %1$s: %2$s";
	public static final String TANGGUO_DELETE_SUCCESS = "Deleted from %1$s: %2$s";
	public static final String TANGGUO_UPDATE_NAME_SUCCESS = "Name of %1$s updated to %2$s";
	public static final String TANGGUO_UPDATE_START_SUCCESS = "Start date of %1$s updated to %2$s";
	public static final String TANGGUO_UPDATE_START_FAIL = "Unable to update Start date, try again";
	public static final String TANGGUO_UPDATE_END_SUCCESS = "End date of %1$s updated to %2$s";
	public static final String TANGGUO_UPDATE_END_FAIL = "Unable to update End date, try again";
	public static final String TANGGUO_UPDATE_PRIORITY_SUCCESS = "Priority of %1$s updated to %2$s";	//print int?
	public static final String TANGGUO_UPDATE_CATEGORY_SUCCESS = "Category of %1$s updated to %2$s";
	public static final String TANGGUO_UPDATE_DONE_SUCCESS = "%1$s completed";
	public static final String TANGGUO_SORT_SUCCESS = "Sorted by %1$s!";

	public static final String TANGGUO_UNDO_SUCCESS = "Undo successful!";
	public static final String TANGGUO_EXIT = "See you again!";

	public static final String TANGGUO_SCHEDULE_CLASH = "Cannot add : %1$s because that time slot is already taken!";

	public static final String TANGGUO_UNDO_NO_COMMAND ="No command to be undone!";
	public static final String TANGGUO_EMPTY_FILE = "%s is empty!";

	public static final String TANGGUO_SEARCH_SUCCESS = "Search results for %1$s ";
	public static final String TANGGUO_SEARCH_FAIL = "The keyword: %1$s is not found!";
	public static final String TANGGUO_PATH_SET = "%1$s data saved to \"%2$s\"!";
	public static final String TANGGUO_IMPORT_SUCCESS = "TangGuo data successfully imported from \"%1$s\"!";
	
	public static final String TANGGUO_IO_EXCEPTION = "An unexpected error has occurred";
	public static final String TANGGUO_OUT_BOUNDS = "The index you entered is invalid, try again";
	public static final String TANGGUO_INVALID_INDEX = "The task index you entered seems to be invalid, try again";
	public static final String TANGGUO_INVALID_DATE = "The date format you entered seems to be invalid, try again";
	public static final String TANGGUO_INVALID_SCHEDULE = "The start time you entered seem to be later than your end time, try again";
	public static final String TANGGUO_INVALID_COMMAND = "The command you entered seems to be invalid, try another command";
	public static final String TANGGUO_DATE_OUT_OF_BOUNDS = "The date or time you have entered is in the wrong format, try again";

	public static final String TANGGUO_INVALID_PRIORITY = "The priority level you entered seems to be invalid, try again";

	public static final String TANGGUO_SHOW_DONE = "The completed events are now shown!";
	public static final String TANGGUO_HIDE_DONE = "The completed events are now hidden!";


	public enum COMMAND_TYPE {
		ADD, ADD_DEADLINE, ADD_SCHEDULE, ADD_TASK, DISPLAY, DELETE, 
		UPDATE_NAME, UPDATE_START, UPDATE_END, UPDATE_PRIORITY, UPDATE_CATEGORY, UNDO, DONE, 
		SORT_NAME, SORT_START, SORT_END, SORT_PRIORITY, SEARCH, TOGGLE, PATH, IMPORT, EXCEPTION, INVALID, EXIT
	};

}
```
